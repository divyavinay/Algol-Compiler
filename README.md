# Algol-Compiler
The manual consists of two distinct parts. In the first part of the manual, sections one to four contain details about the Ting Algol language, details about different parts of the compiler, the DFA used by the compiler and the BNF of the compiler. Part two forms the “Programmer’s Guide” to Tiny Algol W.

The language used to design the compiler is C++ and the IDE is Visual Studio Community edition. The C++ compiler used by visual studio is Visual C++ 14.0.	

Some of the data structures used are
1.	HashTables
2.	Stacks
3.	Arrays

Symbol Table.

The symbol table is constructed using HashTables and stacks. Each HashTable represents a single scope. The symbol table stores the identifier name, the type and offset. This offset is used to access the identifier in code Gen phase of the compiler. 

The symbol table with current scope is maintained using stacks, one stack to maintain the in scope symbol tables and one to maintain the symbol tables that are out of scope. The in scope stack is used to find all identifiers that are local and non local.

Lexical Analyzer

 The main job of the lexical analyzer is to break down the source code into meaningful units called tokens.
In order to do this task we use the DFA that is constructed based on the token numbers below.

Token numbers:  
  1   identifier
  2   any literal (integer such as 123,string "abc", FALSE, TRUE)
  3   types (keywords 'INTEGER' 'STRING' 'LOGICAL')
  4   addition operators (+  -  OR)
  5   multiplication operators (* / DIV  REM AND)
  6   relational operators = , !=, <, >
  7   BEGIN				8   END			(not a token) COMMENT
  9   IF				10  THEN	(*no ELSE in the language*)		
  11  WHILE				12  DO			
  3   INTEGER			3   STRING		
  3   LOGICAL
  2   TRUE				2   FALSE		
  5	DIV				5  REM
  4   OR				5   AND			
  13  READ				13  WRITE		
  13  WRITELN   (IO_operations)
  14  (				15  )			
  16 ;  (not part of a comment)
  17  !  Boolean not		
  18  .  (only at the end of the program)
   
Parser                                                                        
A Parser takes the string of tokens generated by the lexical analyzer and verifies that the string of token names can be generated by the grammar described below.

BNF  used in the language

1.program               :  blockst ‘.’
2.blockst               :  BEGINTOK stats ENDTOK 
3.stats                 :   statmt ';'  stats   | <empty> 
4.decl             	 :  BASICTYPETOK IDTOK 
5.statmt          : decl | ifstat | assstat |  blockst | loopst | iostat | <empty> 
6.assstat           :  idref   ASTOK  expression
7.ifstat            :  IFTOK  expression THENTOK statmt
8.loopst            :  WHILETOK expression DOTOK stat  
9.iostat		   :  READTOK ( idref ) | WRITETOK (expression)
10.expression        :  term expprime       	
11.expprime          :  ADDOPTOK  term expprime   |  <empty>      
12.term              :  relfactor termprime			
13.termprime         :  MULOPTOK  relfactor termprime | <empty>     
14.relfactor         :  factor factorprime			
15.factorprime       :  RELOPTOK  factor          |  <empty>      
 16.factor            :  NOTTOK   factor | idref |LITTOK|'(' expression ')' 
17. idref            : IDTOK


Code Generator
The code gen phase generates the appropriate machine level language that performs the same tasks and the source code. We are using a 3 address code machine language and we will be executing this in MIPS.
Elements of a simple program
BEGIN
	STATS;
END.
  Begin is the first executable symbol of an Algol program. BEGIN indicates the physical beginning of a bloack. END indicates the physical end to a Block or an Algol program. Each “END” corresponds to each “BEGIN”. 
Period indicates the end of the program. It should be preceded by the “END” of a block statement. 
  All statements must end with a “;”.

Declarations

All identifiers of a program except standard functions should be declared with one of the following :
INTEGER, BOOLEAN, STRING,LOGICAL
A declaration of an identifier must appear only after the first BEGIN of a block and is only valid within that block.
TYPE DECLARATION

INTEGER: Integers are strings of digits, optionally preceded by + or –
BOOLEAN: Boolean declared variable may only assume the values ‘TRUE’ or ‘FALSE’.
STRING: Strings are composed of ASCII characters but no special characters.

Operators and Values
An arithmetic expression is a rule for computing a number. According to its type it is called an integer expression or logical expression. The operators +,-,*,/ have conventional meanings of addition, subtraction, multiplication and division. To make the language simple OR is added to additional operators and AND is added to multiplication operators.
 
Arithmetic expressions

examples
1)	A := 10 + 20;
2)	A := 20 -10;
3)	A := B OR C;          (Assuming A,B,C are of type logical)

Multiplication expressions
1)	A := 10 * 20;
2)	A := 20 /10;
3)	A:= B or C       (Assuming A,B,C are of type logical)





Statements

A statement should be a declaration, if/then statement, assignment statement, a while/do loop or a input/output statement.

Assignment : The execution of assignment statement causes the assignment of the value of the expression to the variable provided they are of the same type.

Examples:
P := 10;
sum := X + Y;
If Statement: The execution of the if statement causes certain statements to be executed or skipped depending on the values of specified logical expressions. The if statement is executed in the following steps:
step 1. The logical expression in the if clause is executed.
step 2. If the result of step 1 is true, the execute the statements in after THEN.

Example
IF X <Y
THEN 
X := X+1;

While Loop: The execution of the while loop causes certain statements to be executed one or more times depending on the value of the specified logical expression. The while statement follows similar steps to if statement but in step 2 it executes the statements after ”DO” and goes back to check if the logical expression is true. This process is repeated until logical expression is false.

Example
WHILE X >Y
DO
X:= X+1;


I/O statements
READ gets value from the channel and assigns it to the identifier. WRITE gets value from the identifier and displays it on the channel. WRITELN is similar to WRITE but adds a new line at the end.

Examples
READ(X);
gets integer from the user and assigns it to X.
WRITE(X)
writes value of x to the screen.
WRITELN(x)
writes value to the screen and adds a new line.

