/* **************************************************************************************
Divya Basappa, CS 4110, 14th Feb 2017
Compiler Version:Microsoft (R) C/C++ Optimizing Compiler Version 17
IDE: Visual Studio

The program reads from an intermediate file generated by the scanner.
************************************************************************************** */
#include "stdafx.h"
#include <fstream>
#include <iostream>
#include "Scanner.h"
#include "Buffer.cpp"
#include "HashTable.h"
#include "SymbolTableRoutine.h"
#include "string"
#include <stack>
#include <sstream>

using namespace std;

class ParserClass
{
public:
	int current_token = 0;				// the token read from file
	string lexeme;						//lexeme read from input file
	int tokenNumber;					//token number read from input file
	int line_counter = 1;				// counter for input file so when we get the next line we know which line we need
	SymbolTable symbolTable[10];	 //array of object of class symbolTable, each representing a symbol table for differnt scope
	stack <SymbolTable*>out_of_scope;	//contains the addresses of out of scope blocks for printing
	stack<SymbolTable*>in_scope_stack;  //contains the addresses of the in scope blocks
	SymbolTable symbolTableObj;
	SymbolTable *current_table;			//has the address to the current scope symbol table
	int current_scope = 0;				// contains the scope to be inserted into the symbol table
	int offset=0;							//contains the offset to be inserted to the table

/* ************************************************
Precondition: Outputlisting file exits
Postcondition: Lexeme and token number from each line is read and stored in class variable tokennumber and lexeme
************************************************* */
	int getTokemFromFile() {
		fstream file;								// fstream object to open input file					
		file.open("outputListing.txt");
		int counter = 0;						// iterator for line number
		while (counter != line_counter)
		{
			file >> tokenNumber;
			getline(file, lexeme);
			counter++;
		}

		return tokenNumber;
	}

	/* ************************************************
	Rule 1. program     :  blockst ‘.’
	************************************************* */
	void program(int &currentToken) {
		cout << "1 ";
		blockst(currentToken);
		if (currentToken == 18)					//lexeme "."
		{
			match(18);
			if (current_token == -1)		// -1 being EOF
			{
				cout << "  Successful parse" << endl;
				symbolTableObj.PrintSymbolTable(out_of_scope);
			}
		}
		else
		{
			ParserError(1, lexeme);
		}
	}

private:

	/*****************************************
	Rule 2. blockst     :  BEGINTOK stats ENDTOK

	When we encounter currenToken =7 in blockstat we instantiate a new symbolTable object and push
	it onto in_scope_stack and increment the scope counter by 1. When we encounter currenToken =8
	we decrement the scope counter and push the address of the current symbolTable object 
	onto out_of_scope stcak and pop the in_scope stack.

	******************************************** */
	void blockst(int &currentToken) {
		cout << "2 ";
		if (currentToken == 7)
		{
			match(7);							//lexeme: BEGIN
			symbolTableObj.count_of_table++;	// class variable of symbolTable class that represents the total number of tables in symbolTable array
			symbolTableObj.scope++;				// maintains the current scope
			in_scope_stack.push(&symbolTable[symbolTableObj.count_of_table]);
			current_scope = symbolTableObj.count_of_table;		// initially we set the current scope to be same as table number
			if (in_scope_stack.size() != 0)							// checks the size of in_scope_stack 
				current_table = in_scope_stack.top();				// on size not 0 assigns the address on the top of the stack to current table
			else
				current_table = &symbolTable[symbolTableObj.count_of_table];       // instantiates a new symboltable object.
			stats(currentToken);
			if (currentToken == 8)
			{
				match(8);						//lexeme: END
				out_of_scope.push(current_table);
				symbolTableObj.scope--;
				current_scope = symbolTableObj.scope;       // on end we set the current scope to the previous scope
				in_scope_stack.pop();
				current_table = &symbolTable[symbolTableObj.scope];        // reset the current table with the in_scope table we get after decrementing the scope
			}
			else
				ParserError(2, lexeme);
		}
		else
			ParserError(2, lexeme);
	}

	/* ******************************************
	Rule 3. stats       :   statmt ';'  stats   | <empty>
	******************************************* */
	void stats(int &currentToken) {
		cout << "3 ";
		// if type is decl,IF,BEGIN,WHILE,READ/WRITE,ID calls statmt
		if (currentToken == 3 || currentToken == 9 || currentToken == 7 || currentToken == 11 || currentToken == 13 || currentToken == 1)
		{
			statmt(currentToken);
			if (currentToken == 16)
			{
				match(16);					// lexeme:';'
			}
			else
				ParserError(3, lexeme);
			stats(currentToken);
		}
		else
			return;
	}
	/******************************************
	Rule 4.decl         :  BASICTYPETOK IDTOK
	***********************************************/
	void decl(int &currentToken) {
		cout << "4 ";
		if (currentToken == 3)		{			// lexeme: type
			string type = lexeme;			// assign the value of lexeme type to type before getting the id
			match(3);
			if (currentToken == 1)
			{
				if (symbolTableObj.Find_Local(lexeme, *current_table))
				{
					cout << lexeme << " already declared in current scope." << endl;
				}
				else
				{
					symbolTableObj.Insert(lexeme, type[0], current_table, current_scope, offset);   // if id does not exist in current scope insert into symbol table
					offset = offset - 4;
				}
				match(1);						//lexeme:identifiers
			}
		}
		else
			ParserError(4, lexeme);
	}
	/* ***********************************************************************************
	Rule	5.statmt       : decl | ifstat | assstat |  blockst | loopst | iostat | <empty>
	*************************************************************************************** */
	void statmt(int &currentToken)
	{
		cout << "5 ";
		switch (currentToken)
		{
		case 3: decl(currentToken); break; // if token number 3 then call decl
		case 9:ifstat(currentToken); break; // if token number 9 then call ifstat
		case 1:assstat(currentToken); break; // if tokn number is 1 then call assstat
		case 7: blockst(currentToken); break; // if token number 7 then call ifstat
		case 11: loopst(currentToken); break; // if token number 11 then call ifstat
		case 13: iostat(currentToken); break; // if token number 13 then call ifstat
		default:
			break;
		}
	}

	/* ****************************************************************
	Rule 6.assstat      :  idref   ASTOK  expression
	**********************************************************************/
	void assstat(int &currentToken) {
		cout << "6 ";
		idref(current_token);
		if (current_token == 19)
		{
			match(19);							//lexeme: ':='
			expression(current_token);
		}
		else
			ParserError(6, lexeme);
	}

	/* *******************************************************************
	Rule 7.ifstat       :  IFTOK  expression THENTOK statmt
	********************************************************************* */
	void ifstat(int &currentToken) {
		cout << "7 ";
		if (currentToken == 9)
		{
			match(9);							// lexeme: IF
			expression(currentToken);
			if (currentToken == 10)
			{
				match(10);						// lexeme: THEN
				statmt(currentToken);
			}
			else
				ParserError(7, lexeme);
		}
		else
			ParserError(7, lexeme);
	}

	/* *************************************************************
	Rule 8.loopst : WHILETOK expression DOTOK stat
	************************************************************* */
	void loopst(int &currentToken) {
		cout << "8 ";
		if (currentToken == 11)
		{
			match(11);						// lexeme: WHILE
			expression(currentToken);
			if (currentToken == 12)
			{
				match(12);					// lexeme: DO
				statmt(currentToken);
			}
			else
				ParserError(8, lexeme);
		}
		else
			ParserError(8, lexeme);
	}

	/* *********************************************************
	Rule 9.iostat : READTOK(idref) | WRITETOK(expression)
	************************************************************ */
	void iostat(int &currentToken) {
		cout << "9 ";
		if (currentToken == 13)
		{
			if (lexeme == "READ")
			{
				match(13);						// lexme:READ/WRITE/WRITELN	
				if (currentToken == 14)
				{
					match(14);					//lexeme: '('
					idref(currentToken);
					if (currentToken == 15)
						match(15);				// lexeme: ')'
					else
						ParserError(9, lexeme);
				}
			}
			else if (lexeme == "WRITE" || lexeme == "WRITELN")
			{
				match(13);						// lexme:READ/WRITE/WRITELN	
				if (currentToken == 14)
				{
					match(14);					//lexeme: '('
					expression(currentToken);
					if (currentToken == 15)
						match(15);				// lexeme: ')'
					else
						ParserError(9, lexeme);
				}
				else
					ParserError(9, lexeme);
			}
		}
	}

	/* **********************************************************
	Rule 10. expression : term expprime      E->T E’
	******************************************************** */
	void expression(int &currentToken) {
		cout << "10 ";
		term(currentToken);
		expprime(currentToken);
	}
	/* *************************************************************************
	Rule 11.expprime : ADDOPTOK  term expprime | <empty>        E’->ADD T E’ | eps
	**************************************************************************** */
	void expprime(int &currentToken) {
		cout << "11 ";
		if (currentToken == 4)
		{
			match(4);					//additional operators +,-,OR
			term(currentToken);
			expprime(currentToken);
		}
		else
			return;
	}

	/* ****************************************************
	Rule 12.term : relfactor termprime	   T->RF T’
	******************************************************** */
	void term(int &currentToken) {
		cout << "12 ";
		relfactor(currentToken);
		termprime(currentToken);
	}

	/* ******************************************************************************
	Rule 13.termprime : MULOPTOK  relfactor termprime | <empty>     T’->MUL RF T’ | eps
	********************************************************************************* */
	void termprime(int &currentToken) {
		cout << "13 ";
		if (currentToken == 5)
		{
			match(5);					//multiplication operators *,/, DIV,REM,AND
			relfactor(currentToken);
			termprime(currentToken);
		}
		else
			return;
	}

	/* ***************************************************************************
	Rule 14.relfactor : factor factorprime				    RF->F F’
	**************************************************************************** */
	void relfactor(int &currentToken) {
		cout << "14 ";
		factor(currentToken);
		factorprime(currentToken);
	}

	/* *******************************************************************
	Rule 15.factorprime : RELOPTOK  factor | <empty>        F’->REL F | eps
	********************************************************************** */
	void factorprime(int &currentToken) {
		cout << "15 ";
		if (currentToken == 6)
		{
			match(6);				// relational operators <,>,!=
			factor(currentToken);
		}
		else
			return;
	}

	/* *********************************************************************
	Rule 16.factor           	:  idref  | LITOK  | NOTTOK factor | ‘(‘ exp ‘)‘
	***************************************************************** */
	void factor(int &currentToken) {
		cout << "16 ";
		switch (currentToken)
		{
		case 1: idref(currentToken); break;
		case 2:
			match(2);						//lexeme:All literals
			break;
		case 17:
			match(17);					//lexeme: '!'
			factor(currentToken);
			break;
		case 14:				//lexeme:'('
			match(14);
			expression(currentToken);
			if (currentToken == 15)
				match(15);
			break;
		default:
			ParserError(16, lexeme);
			break;
		}
	}

	/* ******************************
	Rule 17. idref : IDTOK
	***********************/
	void idref(int &currentToken) {
		cout << "17 ";
		if (currentToken == 1)
		{
			if (!symbolTableObj.Find_All(lexeme, in_scope_stack))
				cout << " Undeclared identifier " << lexeme << endl;
			match(1);							//lexeme: Identifiers
		}
		
		else
			ParserError(17, lexeme);
	}

	/* ******************************
	If current token matches with the expected token number passed when the function is called,
	next character is called
	***********************/
	void match(int token)
	{
		line_counter++;
		if (current_token != -1)
			current_token = getTokemFromFile();
	}

	void ParserError(int rule, string lexeme)
	{
		cout << "Unexpected token " << lexeme << " on rule " << rule << endl;
	}
};

int main()
{
	HashTable hashObj = HashTable();
	ScannerClass scanObj = ScannerClass();
	BufferClass bufferObj = BufferClass(hashObj, scanObj);
	ParserClass parserObj = ParserClass();
	bufferObj.GenerateOutputFile();
	parserObj.current_token = parserObj.getTokemFromFile();
	parserObj.program(parserObj.current_token);
	getchar();
	return 0;
}

