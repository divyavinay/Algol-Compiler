/* **************************************************************************************
Divya Basappa, CS 4110, 14th Feb 2017
Compiler Version:Microsoft (R) C/C++ Optimizing Compiler Version 17
IDE: Visual Studio

The program reads from an intermediate file generated by the scanner.
************************************************************************************** */
#include "stdafx.h"
#include <fstream>
#include <iostream>
#include "Scanner.h"
#include "Buffer.cpp"
#include "HashTable.h"
#include "string"
#include <sstream>

using namespace std;

class ParserClass
{
public:
	int current_token = 0;				// the token read from file
	string lexeme;						//lexeme read from input file
	int tokenNumber;					//token number read from input file
	int line_counter = 1;				// counter for input file so when we get the next line we know which line we need

/* ************************************************
Precondition: Outputlisting file exits
Postcondition: Lexeme and token number from each line is read and stored in class variable tokennumber and lexeme
************************************************* */
	int getTokemFromFile() {
		fstream file;								// fstream object to open input file					
		file.open("outputListing.txt");
		int counter = 0;						// iterator for line number
		while (counter != line_counter)
		{
			file >> tokenNumber >> lexeme;
			counter++;
		}
		return tokenNumber;
	}

	/* ************************************************
	Rule 1. program     :  blockst ‘.’
	************************************************* */
	void program(int &currentToken) {
		cout << "1 ";
		blockst(currentToken);
		if (currentToken == 18)					//lexeme "."
		{
			match(18);
			if (current_token == -1)		// -1 being EOF
				cout << "  Success" << endl;
		}
		else
		{
			ParserError(1, lexeme);
		}
	}

private:

	/*****************************************
	Rule 2. blockst     :  BEGINTOK stats ENDTOK
	******************************************** */
	void blockst(int &currentToken) {
		cout << "2 ";
		if (currentToken == 7)
		{
			match(7);							//lexeme: BEGIN
			stats(currentToken);
			if (currentToken == 8)
				match(8);						//lexeme: END
			else
				ParserError(2, lexeme);
		}
		else
			ParserError(2, lexeme);
	}

	/* ******************************************
	Rule 3. stats       :   statmt ';'  stats   | <empty>
	******************************************* */
	void stats(int &currentToken) {
		cout << "3 ";
		// if type is decl,IF,BEGIN,WHILE,READ/WRITE,ID calls statmt
		if (currentToken == 3 || currentToken == 9 || currentToken == 7 || currentToken == 11 || currentToken == 13 || currentToken == 1)
		{
			statmt(currentToken);
			if (currentToken == 16)
			{
				match(16);					// lexeme:';'
			}
			else
				ParserError(3, lexeme);
			stats(currentToken);
		}
		else
			return;
	}

	/* *****************************************
	Rule 4.decl         :  BASICTYPETOK IDTOK
	********************************************** */
	void decl(int &currentToken) {
		cout << "4 ";
		if (currentToken == 3)					// lexeme: type
		{
			match(3);
			if (currentToken == 1)
				match(1);						//lexeme:identifiers
		}
		else
			ParserError(4, lexeme);
	}

	/* ***********************************************************************************
	Rule	5.statmt       : decl | ifstat | assstat |  blockst | loopst | iostat | <empty>
	*************************************************************************************** */
	void statmt(int &currentToken)
	{
		cout << "5 ";
		switch (currentToken)
		{
		case 3: decl(currentToken); break; // if token number 3 then call decl
		case 9:ifstat(currentToken); break; // if token number 9 then call ifstat
		case 1:assstat(currentToken); break; // if tokn number is 1 then call assstat
		case 7: blockst(currentToken); break; // if token number 7 then call ifstat
		case 11: loopst(currentToken); break; // if token number 11 then call ifstat
		case 13: iostat(currentToken); break; // if token number 13 then call ifstat
		default: 
			break;
		}
	}

	/* ****************************************************************
	Rule 6.assstat      :  idref   ASTOK  expression
	**********************************************************************/
	void assstat(int &currentToken) {
		cout << "6 ";
		idref(current_token);
		if (current_token == 19)			
		{
			match(19);							//lexeme: ':='
			expression(current_token);
		}
		else
			ParserError(6, lexeme);
	}

	/* *******************************************************************
	Rule 7.ifstat       :  IFTOK  expression THENTOK statmt
	********************************************************************* */
	void ifstat(int &currentToken) {
		cout << "7 ";
		if (currentToken == 9)
		{
			match(9);							// lexeme: IF
			expression(currentToken);
			if (currentToken == 10)
			{
				match(10);						// lexeme: THEN
				statmt(currentToken);
			}
			else
				ParserError(7, lexeme);
		}
		else
			ParserError(7, lexeme);
	}

	/* *************************************************************
	Rule 8.loopst : WHILETOK expression DOTOK stat
	************************************************************* */
	void loopst(int &currentToken) {
		cout << "8 ";
		if (currentToken == 11)
		{
			match(11);						// lexeme: WHILE
			expression(currentToken);
			if (currentToken == 12)
			{
				match(12);					// lexeme: DO
				stats(currentToken);
			}
			else
				ParserError(8, lexeme);
		}
		else
			ParserError(8, lexeme);
	}

	/* *********************************************************
	Rule 9.iostat : READTOK(idref) | WRITETOK(expression)
	************************************************************ */
	void iostat(int &currentToken) {
		cout << "9 ";
		if (currentToken == 13)
		{
			match(13);						// lexme:READ/WRITE
			if (currentToken == 14)
			{
				match(14);					//lexeme: '('
				idref(currentToken);
				expression(currentToken);
				if (currentToken == 15)
					match(15);				// lexeme: ')'
				else
					ParserError(9, lexeme);
			}
			else
				ParserError(9, lexeme);
		}
	}

	/* **********************************************************
	Rule 10. expression : term expprime      E->T E’
	******************************************************** */
	void expression(int &currentToken) {
		cout << "10 ";
		term(currentToken);
		expprime(currentToken);
	}
	/* *************************************************************************
	Rule 11.expprime : ADDOPTOK  term expprime | <empty>        E’->ADD T E’ | eps
	**************************************************************************** */
	void expprime(int &currentToken) {
		cout << "11 ";
		if (currentToken == 4)
		{
			match(4);					//additional operators +,-,OR
			term(currentToken);
			expprime(currentToken);
		}
		else
			return;
	}

	/* ****************************************************
	Rule 12.term : relfactor termprime	   T->RF T’
	******************************************************** */
	void term(int &currentToken) {
		cout << "12 ";
		relfactor(currentToken);
		termprime(currentToken);
	}

	/* ******************************************************************************
	Rule 13.termprime : MULOPTOK  relfactor termprime | <empty>     T’->MUL RF T’ | eps
	********************************************************************************* */
	void termprime(int &currentToken) {
		cout << "13 ";
		if (currentToken == 5)
		{
			match(5);					//multiplication operators *,/, DIV,REM,AND
			relfactor(currentToken);
			termprime(currentToken);
		}
		else
			return;
	}

	/* ***************************************************************************
	Rule 14.relfactor : factor factorprime				    RF->F F’
	**************************************************************************** */
	void relfactor(int &currentToken) {
		cout << "14 ";
		factor(currentToken);
		factorprime(currentToken);
	}

	/* *******************************************************************
	Rule 15.factorprime : RELOPTOK  factor | <empty>        F’->REL F | eps
	********************************************************************** */
	void factorprime(int &currentToken) {
		cout << "15 ";
		if (currentToken == 6)
		{
			match(6);				// relational operators <,>,!=
			factor(currentToken);
		}
		else
			return;
	}

	/* *********************************************************************
	Rule 16.factor           	:  idref  | LITOK  | NOTTOK factor | ‘(‘ exp ‘)‘
	***************************************************************** */
	void factor(int &currentToken) {
		cout << "16 ";
		switch (currentToken)
		{
		case 1: idref(currentToken); break;
		case 2: 
			match(2);						//lexeme:All literals
			break;
		case 17: 
			match(17);					//lexeme: '!'
			factor(currentToken);
			 break;
		case 14:				//lexeme:'('
			match(14);
			expression(currentToken);
				if (currentToken == 15)
					match(15);
				break;
		default:
			ParserError(16, lexeme);
			break;
		}
	}

	/* ******************************
	Rule 17. idref : IDTOK
	***********************/
	void idref(int &currentToken) {
		cout << "17 ";
		if (currentToken == 1)
			match(1);							//lexeme: Identifiers
		else
			ParserError(17, lexeme);
	}

	/* ******************************
	If current token matches with the expected token number passed when the function is called,
	next character is called
	***********************/
	void match(int token)
	{
		line_counter++;
		if (current_token != -1)
			current_token = getTokemFromFile();
	}

	void ParserError(int rule, string lexeme)
	{
		cout <<"Unexpected token " << lexeme <<" on rule "<<rule <<endl;
	}
};

int main()
{
	HashTable hashObj = HashTable();
	ScannerClass scanObj = ScannerClass();
	BufferClass bufferObj = BufferClass(hashObj, scanObj);
	ParserClass parserObj = ParserClass();
	bufferObj.GenerateOutputFile();
	parserObj.current_token = parserObj.getTokemFromFile();
	parserObj.program(parserObj.current_token);
	getchar();
	return 0;
}

