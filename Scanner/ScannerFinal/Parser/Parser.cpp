/* **************************************************************************************
Divya Basappa, CS 4110, 14th Feb 2017
Compiler Version:Microsoft (R) C/C++ Optimizing Compiler Version 17
IDE: Visual Studio

The program reads from an intermediate file generated by the scanner.
************************************************************************************** */
#include "stdafx.h"
#include <fstream>
#include <iostream>
#include <sstream>
#include "Scanner.h"
#include "Buffer.cpp"
#include "HashTable.h"
#include "CodeGenerator.cpp"
#include "SymbolTableRoutine.h"
#include "string"
#include <stack>
#include <sstream>

using namespace std;

struct expRec {
	char type;							// stores the type of token
	int location;						// stores the location of token on stack
	string label;
};

class ParserClass
{
public:
	CodeGeneratorClass codeGenObj = CodeGeneratorClass();				// create object to access code generation methods
	int current_token = 0;				
	string lexeme;					
	int tokenNumber;					
	int line_counter = 1;				// counter for input file so when we get the next line we know which line we need
	SymbolTable symbolTable[10];	 //array of object of class symbolTable, each representing a symbol table for differnt scope
	stack <SymbolTable*>out_of_scope;	//contains the addresses of out of scope blocks for printing
	stack<SymbolTable*>in_scope_stack;  //contains the addresses of the in scope blocks
	SymbolTable symbolTableObj;
	SymbolTable *current_table;			//has the address to the current scope symbol table
	int current_scope = 0;				// contains the scope to be inserted into the symbol table
	int offset=0;							//contains the offset to be inserted to the table
	string operation;
/* ************************************************
Precondition: Outputlisting file exits
Postcondition: Lexeme and token number from each line is read and stored in class variable tokennumber and lexeme
************************************************* */
	int getTokemFromFile() {
		fstream file;								// fstream object to open input file					
		file.open("outputListing.txt");
		int counter = 0;						// iterator for line number
		while (counter != line_counter)
		{
			file >> tokenNumber;
			getline(file,lexeme);
			counter++;
		}
		return tokenNumber;
	}

	/* ************************************************
	Rule 1. program     :  blockst ‘.’
	************************************************* */
	void program(int &currentToken,expRec &ex) {
		cout << "1 ";
		codeGenObj.WriteProlog();
		blockst(currentToken,ex);
		if (currentToken == 18)				//lexeme "."
		{
			match(18);
			codeGenObj.copyDataSectionToFile();
			codeGenObj.WritePostLog();
			if (current_token == -1)		// -1 being EOF
			{
				cout << "  Successful parse" << endl;
				symbolTableObj.PrintSymbolTable(out_of_scope);
				codeGenObj.close_file();
			}
			else
				ParserError(1, lexeme);
		}
		else
			ParserError(1, lexeme);
	}

private:

	/*****************************************
	Rule 2. blockst     :  BEGINTOK stats ENDTOK

	When we encounter currentToken =7 in blockstat we call begin_scope function 
	that creates a new symbol table. When we encounter currentToken =8 we call end_of_scope 
	which pops current symbol table
	******************************************** */
	void blockst(int &currentToken,expRec &ex) {
		cout << "2 ";
		if (currentToken == 7)
		{
			int temp_current_offset = offset;
			codeGenObj.GeneComments("Begin Block");
			match(7);							//lexeme: BEGIN
			begin_of_scope();
			stats(currentToken,ex);
			if (currentToken == 8)
			{
				codeGenObj.GeneComments("End Block");
				match(8);						//lexeme: END
				end_of_scope();
				offset = temp_current_offset;
			}
			else
				ParserError(2, lexeme);
		}
		else
			ParserError(2, lexeme);
	}

	/* ******************************************
	Rule 3. stats       :   statmt ';'  stats   | <empty>
	******************************************* */
	void stats(int &currentToken,expRec &ex) {
		cout << "3 ";
		// if type is decl,IF,BEGIN,WHILE,READ/WRITE,ID calls statmt
		if (currentToken == 3 || currentToken == 9 || currentToken == 7 || currentToken == 11 || currentToken == 13 || currentToken == 1)
		{
			statmt(currentToken,ex);
			if (currentToken == 16)
			{
				match(16);					// lexeme:';'
			}
			else
				ParserError(3, lexeme);
			stats(currentToken,ex);
		}
		else
			return;
	}
	/******************************************
	Rule 4.decl         :  BASICTYPETOK IDTOK
	***********************************************/
	void decl(int &currentToken) {
		cout << "4 ";
		if (currentToken == 3)		{			// lexeme: type
			string type = lexeme;			// assign the value of lexeme type to type before getting the id
			match(3);
			if (currentToken == 1)
			{
				if (symbolTableObj.Find_Local(lexeme, *current_table))
				{
					cout << lexeme << " already declared in current scope." << endl;
				}
				else
				{
					symbolTableObj.Insert(lexeme, type[0], current_table, current_scope, offset);   // if id does not exist in current scope insert into symbol table
					offset = offset - 4;
				}
				match(1);						//lexeme:identifiers
			}
		}
		else
			ParserError(4, lexeme);
	}
	/* ***********************************************************************************
	Rule	5.statmt       : decl | ifstat | assstat |  blockst | loopst | iostat | <empty>
	*************************************************************************************** */
	void statmt(int &currentToken,expRec &ex)
	{
		cout << "5 ";
		switch (currentToken)
		{
		case 3: decl(currentToken); break; // if token number 3 then call decl
		case 9:ifstat(currentToken,ex); break; // if token number 9 then call ifstat
		case 1:assstat(currentToken,ex); break; // if tokn number is 1 then call assstat
		case 7: blockst(currentToken,ex); break; // if token number 7 then call ifstat
		case 11: loopst(currentToken,ex); break; // if token number 11 then call ifstat
		case 13: iostat(currentToken,ex); break; // if token number 13 then call ifstat
		default:
			break;
		}
	}

	/* ****************************************************************
	Rule 6.assstat      :  idref   ASTOK  expression
	**********************************************************************/
	void assstat(int &currentToken,expRec &ex) {
		cout << "6 ";
		idref(current_token,ex);
		if (current_token == 19)
		{
			match(19);							//lexeme: ':='
			expRec lhs = ex;
			expression(current_token,ex);
			if (lhs.type == ex.type)
			{
				codeGenObj.CodeGen("lw", "$t0,", to_string(ex.location),"($sp)");
				codeGenObj.CodeGen("sw", "$t0,", to_string(lhs.location), "($sp)");
			}
			else
				cout << "Incompatible types" << endl;
		}
		else
			ParserError(6, lexeme);
	}

	/* *******************************************************************
	Rule 7.ifstat       :  IFTOK  expression THENTOK statmt
	********************************************************************* */
	void ifstat(int &currentToken, expRec &ex) {
		cout << "7 ";
		string label;
		if (currentToken == 9)
		{
			label = codeGenObj.GenLabel("if loop");
			codeGenObj.GeneComments("Begin " + label);
			match(9);							// lexeme: IF
			expression(currentToken,ex);
			if (ex.type == 'B')
			{
				codeGenObj.CodeGen("lw", "$t0,", to_string(ex.location), "($sp)");
				codeGenObj.CodeGen("beq", "$t0,", "$0,", label);
				if (currentToken == 10)
				{
					codeGenObj.GenLabel(lexeme);
					codeGenObj.CodeGen(codeGenObj.label, ":", "", "");
					codeGenObj.GeneComments(codeGenObj.label);
					match(10);			// lexeme: THEN
					statmt(currentToken, ex);
					codeGenObj.CodeGen(label, ":", "", "");
				}
				else
					ParserError(7, lexeme);
			}
			codeGenObj.GeneComments(label);
		}
		else
			ParserError(7, lexeme);
	}

	/* *************************************************************
	Rule 8.loopst : WHILETOK expression DOTOK stat
	************************************************************* */
	void loopst(int &currentToken, expRec &ex) {
		cout << "8 ";
		string TopWhileLabel;
		string EndWhileLable;
		if (currentToken == 11)
		{
			TopWhileLabel = codeGenObj.GenLabel("TopWhileLabel");
			codeGenObj.CodeGen(TopWhileLabel, ":", "", "");
			match(11);						// lexeme: WHILE
			expression(currentToken,ex);
			if (ex.type == 'B')
			{
				codeGenObj.CodeGen("lw", "$t0,", to_string(ex.location), "($sp)");
				EndWhileLable = codeGenObj.GenLabel("EndWhileLable");
				codeGenObj.CodeGen("beq", "$t0,", "$0,", EndWhileLable);
				if (currentToken == 12)
				{
					match(12);					// lexeme: DO
					stats(currentToken, ex);
					codeGenObj.CodeGen("j", TopWhileLabel, "", "");
					codeGenObj.CodeGen(EndWhileLable, ":", "", "");
				}
				else
					ParserError(8, lexeme);
			}
			else
				cout << "Incompatible type" << endl;
		}
		else
			ParserError(8, lexeme);
	}

	/* *********************************************************
	Rule 9.iostat : READTOK(idref) | WRITETOK(expression)
	************************************************************ */
	void iostat(int &currentToken, expRec &ex) {
		cout << "9 ";
		string temp_token = lexeme; 
		bool IsWriteln = false;
		if (currentToken == 13)
		{
			match(13);						// lexme:READ/WRITE/WRITELN	
			if (temp_token == "READ")
			{
				if (currentToken == 14)
				{
					match(14);					//lexeme: '('
					idref(currentToken, ex);
					if (ex.type == 'I')
					{
						codeGenObj.CodeGen("syscall","$read_int","","");
						codeGenObj.CodeGen("sw", "$v0,", to_string(ex.location), "($sp)");
					}
					else if (ex.type == 'L')
					{
						// 
					}
					if (currentToken == 15)
						match(15);				// lexeme: ')'
					else
						ParserError(9, lexeme);
				}
				else
					ParserError(9, lexeme);
			}
			else if (temp_token == "WRITE" || temp_token == "WRITELN")
			{
				if (temp_token == "WRITELN")
					 IsWriteln = true;
				if (currentToken == 14)
				{
					match(14);					//lexeme: '('
					expression(currentToken, ex);
					if (ex.type == 'I')
					{
						codeGenObj.CodeGen("lw", "$a0,", to_string(ex.location), "($sp)");
						codeGenObj.CodeGen("syscall","$print_int","","");
					}
					else if (ex.type == 'L')
					{
						string label = codeGenObj.GenLabel("Cont_bool" + lexeme);
						codeGenObj.CodeGeneDataSection("True: .asciiz \" True\" ");
						codeGenObj.CodeGeneDataSection("False: .asciiz \" False\" ");
						codeGenObj.CodeGen("lw", "$t0,", to_string(ex.location), "($sp)");
						codeGenObj.CodeGen("beq", "$t0,", "0,", "False");
						codeGenObj.CodeGen("la", "$a0,", "True", "");
						codeGenObj.CodeGen("li", "$v0,", "4","");
						codeGenObj.CodeGen("syscall","","","");
						codeGenObj.CodeGen("b", label, "", "");
						codeGenObj.CodeGen("False:", "", "", "");
						codeGenObj.CodeGen("la", "$a0,", "False", "");
						codeGenObj.CodeGen("li", "$v0,", "4", "");
						codeGenObj.CodeGen("syscall", "", "", "");
						codeGenObj.CodeGen(label, ":", "", "");
					}
					else if (ex.type == 'S')
					{
						codeGenObj.CodeGen("la", "$a0,", ex.label, "");
						codeGenObj.CodeGen("li", "$v0,", "4", "");
						codeGenObj.CodeGen("syscall","","","");
					}
					if (IsWriteln == true)
					{
						codeGenObj.CodeGen("la", "$a0,", "nl","");
						codeGenObj.CodeGen("li", "$v0,", "4", "");
						codeGenObj.CodeGen("syscall", "", "", "");
						codeGenObj.CodeGeneDataSection("nl: .asciiz \"\\n\"");
					}

					if (currentToken == 15)
						match(15);				// lexeme: ')'
					else
						ParserError(9, lexeme);
				}
				else
					ParserError(9, lexeme);
			}
		}
	}

	/* **********************************************************
	Rule 10. expression : term expprime      E->T E’
	******************************************************** */
	void expression(int &currentToken,expRec &ex) {
		cout << "10 ";
		term(currentToken,ex);
		expprime(currentToken,ex);
	}
	/* *************************************************************************
	Rule 11.expprime : ADDOPTOK  term expprime | <empty>        E’->ADD T E’ | eps
	**************************************************************************** */
	void expprime(int &currentToken,expRec &ex) {
		cout << "11 ";
		if (currentToken == 4)
		{
			
			expRec lhs = ex;								// stores the exRec locally
			char op = lexeme[0];
			match(4);					//additional operators +,-,OR
			term(currentToken,ex);
			if (lhs.type == 'I' && ex.type == 'I')
			{
				if (op == '+') operation = "add";
				else if (op == '-') operation = "sub";
				
				codeGenObj.CodeGen("lw ", "$t0,", to_string(lhs.location), "($sp)");
				codeGenObj.CodeGen("lw ", "$t1,", to_string(ex.location), "($sp)");
				codeGenObj.CodeGen(operation, "$t0,", "$t0,", "$t1");
				codeGenObj.CodeGen("sw", "$t0,", to_string(offset), "($sp)");
				ex.type = 'I';
				ex.location = offset;
				offset = offset - 4;
			}
			else if (lhs.type == 'L' && ex.type == 'L')
			{
				operation = "or";
				codeGenObj.CodeGen("lw ", "$t0,", to_string(lhs.location), "($sp)");
				codeGenObj.CodeGen("lw ", "$t1,", to_string(ex.location), "($sp)");
				codeGenObj.CodeGen(operation, "$t0,", "$t1,", "$t0");
				codeGenObj.CodeGen("sw", "$t0,", to_string(offset), "($sp)");
				ex.type = 'L';
				ex.location = offset;
				offset = offset - 4;
			}
			else
				cout << "Incompatible operators" << endl;
			expprime(currentToken,ex);
		}
		else
			return;
	}

	/* ****************************************************
	Rule 12.term : relfactor termprime	   T->RF T’
	******************************************************** */
	void term(int &currentToken,expRec &ex) {
		cout << "12 ";
		relfactor(currentToken,ex);
		termprime(currentToken,ex);
	}

	/* ******************************************************************************
	Rule 13.termprime : MULOPTOK  relfactor termprime | <empty>     T’->MUL RF T’ | eps
	********************************************************************************* */
	void termprime(int &currentToken, expRec &ex) {
		cout << "13 ";
		if (currentToken == 5)
		{
			
			expRec lhs = ex;								// stores the exRec locally
			char op = lexeme[0];
			match(5);					//multiplication operators *,/, DIV,REM,AND
			relfactor(currentToken, ex);
			termprime(currentToken, ex);
			if (lhs.type == 'I' && ex.type == 'I')
			{
				if (op == '*') operation = "mult";
				else if (op == '/') operation = "div";
				codeGenObj.CodeGen("lw ", "$t0,", to_string(lhs.location), "($sp)");
				codeGenObj.CodeGen("lw ", "$t1,", to_string(ex.location), "($sp)");
				codeGenObj.CodeGen(operation, "$t0,", "$t1,","");
				codeGenObj.CodeGen("sw", "$t0,", to_string(offset), "($sp)");
				ex.type = 'I';
				ex.location = offset;
				offset = offset - 4;
			}
			else  if (lhs.type == 'L' && ex.type == 'L')
			{
				operation = "and";
				codeGenObj.CodeGen("lw ", "$t0,", to_string(lhs.location), "($sp)");
				codeGenObj.CodeGen("lw ", "$t1,", to_string(ex.location), "($sp)");
				codeGenObj.CodeGen(operation, "$t0,", "$t1,", "");
				codeGenObj.CodeGen("sw", "$t0,", to_string(offset), "($sp)");
				ex.type = 'L';
				ex.location = offset;
				offset = offset - 4;
			}
			else
				cout << "Incompatible operators" << endl;
		}
		else
			return;
	}

	/* ***************************************************************************
	Rule 14.relfactor : factor factorprime				    RF->F F’
	**************************************************************************** */
	void relfactor(int &currentToken, expRec &ex) {
		cout << "14 ";
		factor(currentToken,ex);
		factorprime(currentToken,ex);
	}

	/* *******************************************************************
	Rule 15.factorprime : RELOPTOK  factor | <empty>        F’->REL F | eps
	********************************************************************** */
	void factorprime(int &currentToken, expRec &ex) {
		cout << "15 ";
		if (currentToken == 6)
		{
			string true_label = codeGenObj.GenLabel("true_label");
			expRec lhs = ex;
			if (lexeme == "<") operation = "blt";
			else if (lexeme == ">") operation = "bgt";
			else if (lexeme == "!=") operation = "bne";
			match(6);				// relational operators <,>,!=
			factor(currentToken,ex);
			if (lhs.type == 'I' && ex.type == 'I')
			{
				codeGenObj.CodeGen("lw", "$t0,", to_string(lhs.location), "($sp)");
				codeGenObj.CodeGen("lw", "$t1,", to_string(ex.location), "($sp)");
				codeGenObj.CodeGen("li", "$t2,", "1", "");			// 1 = true
				codeGenObj.CodeGen(operation, "$t0,", "$t1,", true_label);
				codeGenObj.CodeGen("li", "$t2,", "0", "");			//0 = false
				codeGenObj.CodeGen(true_label, ":", "", "");
				codeGenObj.CodeGen("sw", "$t2,", to_string(offset), "($sp)");
				ex.type = 'B';
				ex.location = offset;
				offset = offset - 4;
			}
			else if (lhs.type == 'L' && ex.type == 'L')
			{
				codeGenObj.CodeGen("lw", "$t0,", to_string(lhs.location), "($sp)");
				codeGenObj.CodeGen("lw", "$t1,", to_string(ex.location), "($sp)");
				codeGenObj.CodeGen("li", "$t2,", "1", "");
				codeGenObj.CodeGen(operation, "$t0,", "$t1,", true_label);
				codeGenObj.CodeGen("li", "$t2,", "0", "");
				codeGenObj.CodeGen(true_label, ":", "", "");
				codeGenObj.CodeGen("sw", "$t2,", to_string(offset), "($sp)");
				ex.type = 'B';
				ex.location = offset;
				offset = offset - 4;
			}
			else
			{
				cout << " Incompatible operands" << endl;
			}
		}
		else
			return;
	}

	/* *********************************************************************
	Rule 16.factor           	:  idref  | LITOK  | NOTTOK factor | ‘(‘ exp ‘)‘
	***************************************************************** */
	void factor(int &currentToken,expRec &ex) {
		cout << "16 ";
		switch (currentToken)
		{
		case 1: idref(currentToken,ex); break;
		case 2: if (getType(lexeme) == 'I')
				{
					codeGenObj.CodeGen("li", "$t0,",lexeme,"");					// loads literal to register $t0
					ex.type = 'I';
					ex.location = offset;
					codeGenObj.CodeGen("sw", "$t0,", to_string(ex.location),"($sp)");
					offset = offset - 4;
					match(2);						//lexeme:All literals
				}
				else if (getType(lexeme) == 'L')
				{
					int token_type;
					if (lexeme[0] == 'T')token_type = 1;
					else token_type = 0;
					codeGenObj.CodeGen("li", "$t0,", to_string(token_type), "");					// loads literal to register $t0
					ex.type = 'L';
					ex.location = offset;
					codeGenObj.CodeGen("sw", "$t0,", to_string(ex.location), "($sp)");
					offset = offset - 4;
					match(2);
				}
				else
				{
						string label;
						label = codeGenObj.GenLabel(lexeme);
						codeGenObj.CodeGeneDataSection(label + ": .asciiz " + lexeme);
						ex.label = label;
						ex.type = 'S';
						match(2);
				}
			break;
		case 17:
			match(17);					//lexeme: '!'
			factor(currentToken,ex);
			break;
		case 14:				//lexeme:'('
			match(14);
			expression(currentToken,ex);
			if (currentToken == 15)
				match(15);
			break;
		default:
			ParserError(16, lexeme);
			break;
		}
	}

	/* ******************************
	Rule 17. idref : IDTOK
	***********************/
	void idref(int &currentToken,expRec &ex) {
		cout << "17 ";
		if (currentToken == 1)
		{
			item *Ptr = symbolTableObj.Find_All(lexeme, in_scope_stack);				// calls Find all function of symbol table and if id exits in symbol table returns a pointer to the object
			if (Ptr == NULL)
				cout << " Undeclared identifier " << lexeme << endl;
			else
			{ 
				ex.type = Ptr->type;						// assigns type of id from symbol table to exRec type
				ex.location = Ptr->offset;					// assigns offset of id in stack
				match(1);							//lexeme: Identifiers
			}
		}
		else
			ParserError(17, lexeme);
	}

	/* ******************************
	If current token matches with the expected token number passed when the function is called,
	next character is called
	***********************/
	void match(int token)
	{
			line_counter++;
			if (current_token != -1)
				current_token = getTokemFromFile();
	}

	void ParserError(int rule, string lexeme)
	{
		cout << "Unexpected token " << lexeme << " on rule " << rule << endl;
	}
/*******************************************************************************
Creates a new symbol table and pushes the address of the hashTable onto the 
in_scope_stack.If the in_scope_stack is 0 then a new symbol Table is created
else top of in_scope stack is assigned to current_table
**********************************************************************************/

	void begin_of_scope()
	{
		symbolTableObj.count_of_table++;	// class variable of symbolTable class that represents the total number of tables in symbolTable array
		symbolTableObj.scope++;				// maintains the current scope
		in_scope_stack.push(&symbolTable[symbolTableObj.count_of_table]);
		current_scope = symbolTableObj.count_of_table;		// initially we set the current scope to be same as table number
		if (in_scope_stack.size() != 0)							// checks the size of in_scope_stack 
			current_table = in_scope_stack.top();				// on size not 0 assigns the address on the top of the stack to current table
		else
			current_table = &symbolTable[symbolTableObj.count_of_table];       // instantiates a new symboltable object.
	}

/**********************************************************************
Pops the current scope from in_scope_tsack and pushes in onto out_of_scope stack
*********************************************************************/

	void end_of_scope()
	{
		out_of_scope.push(current_table);
		symbolTableObj.scope--;
		current_scope = symbolTableObj.scope;       // on end we set the current scope to the previous scope
		in_scope_stack.pop();
		current_table = &symbolTable[symbolTableObj.scope];        // reset the current table with the in_scope table we get after decrementing the scope
	}

	char getType(string lexeme) 
	{   
		char ch;
		if (lexeme[0] == 'T' || lexeme[0] == 'F') ch = 'L';
		else if (isdigit(lexeme[0])) ch = 'I';
		else ch = 'S';
		return ch;
	}
};

int main()
{
	HashTable hashObj = HashTable();
	ScannerClass scanObj = ScannerClass();
	BufferClass bufferObj = BufferClass(hashObj, scanObj);
	ParserClass parserObj = ParserClass();
	bufferObj.GenerateOutputFile();
	parserObj.current_token = parserObj.getTokemFromFile();
	expRec ex;
	parserObj.program(parserObj.current_token,ex);
	getchar();
	return 0;
}

